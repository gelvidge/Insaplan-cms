import { payloadGraphQL, payloadRest, fetchWithCache } from '@/lib/payloadClient'

// Type definitions (will be generated by Payload)
export interface Page {
    id: string
    title: string
    slug: string
    content: any
    layout: 'standard' | 'fullWidth' | 'landing'
    status: 'draft' | 'published' | 'archived'
    seo?: {
        metaTitle?: string
        metaDescription?: string
        ogImage?: {
            url: string
            alt: string
        }
    }
}

export interface BlogPost {
    id: string
    title: string
    slug: string
    excerpt: string
    content: any
    featuredImage: {
        url: string
        alt: string
    }
    author: {
        name: string
    }
    category: string
    tags?: string[]
    publishedDate: string
    readTime?: number
    status: 'draft' | 'published' | 'archived'
}

export interface KnowledgeBaseArticle {
    id: string
    title: string
    slug: string
    content: any
    category: string
    subcategory?: string
    relatedArticles?: KnowledgeBaseArticle[]
    viewCount: number
    helpfulCount: number
    notHelpfulCount: number
    status: 'draft' | 'published' | 'archived'
}

export interface FAQ {
    id: string
    question: string
    answer: any
    category: string
    order: number
    helpfulCount: number
    notHelpfulCount: number
}

export interface PricingPlan {
    id: string
    planName: string
    planType: string
    description: string
    price: number
    billingPeriod: 'monthly' | 'annual'
    currency: string
    features: Array<{
        feature: string
        included: boolean
        limit?: string
    }>
    cta: {
        text: string
        url: string
        variant: 'primary' | 'secondary' | 'outline'
    }
    popular: boolean
    order: number
}

export interface Solution {
    id: string
    title: string
    slug: string
    subtitle: string
    heroImage?: {
        url: string
        alt: string
    }
    overview: any
    keyFeatures: Array<{
        title: string
        description: string
        icon?: string
    }>
    useCases: Array<{
        title: string
        description: string
        image?: {
            url: string
            alt: string
        }
    }>
    status: 'draft' | 'published' | 'archived'
}

export interface SiteSettings {
    siteName: string
    siteDescription: string
    logo: {
        url: string
        alt: string
    }
    favicon: {
        url: string
    }
    socialLinks: {
        twitter?: string
        linkedin?: string
        github?: string
        facebook?: string
        instagram?: string
        youtube?: string
    }
    analytics: {
        googleAnalyticsId?: string
        googleTagManagerId?: string
        plausibleDomain?: string
    }
    contact: {
        email: string
        supportEmail: string
        salesEmail?: string
        phone?: string
        address?: string
    }
}

// Fetch functions

export async function fetchPage(slug: string): Promise<Page | null> {
    return fetchWithCache(`page:${slug}`, async () => {
        const response = await payloadRest.get<{ docs: Page[] }>('/pages', {
            where: {
                slug: { equals: slug },
                status: { equals: 'published' }
            },
            limit: 1
        })

        return response.docs[0] || null
    })
}

export async function fetchAllPages(): Promise<Page[]> {
    return fetchWithCache('pages:all', async () => {
        const response = await payloadRest.get<{ docs: Page[] }>('/pages', {
            where: {
                status: { equals: 'published' }
            },
            limit: 1000
        })

        return response.docs
    })
}

export async function fetchBlogPost(slug: string): Promise<BlogPost | null> {
    return fetchWithCache(`blog:${slug}`, async () => {
        const response = await payloadRest.get<{ docs: BlogPost[] }>(
            '/blog-posts',
            {
                where: {
                    slug: { equals: slug },
                    status: { equals: 'published' }
                },
                limit: 1
            }
        )

        return response.docs[0] || null
    })
}

export async function fetchAllBlogPosts(
    limit: number = 10,
    page: number = 1
): Promise<{ docs: BlogPost[]; totalDocs: number; hasNextPage: boolean }> {
    return fetchWithCache(`blog:all:${limit}:${page}`, async () => {
        return payloadRest.get<{
            docs: BlogPost[]
            totalDocs: number
            hasNextPage: boolean
        }>('/blog-posts', {
            where: {
                status: { equals: 'published' }
            },
            limit,
            page,
            sort: '-publishedDate'
        })
    })
}

export async function fetchKnowledgeBaseArticle(
    slug: string
): Promise<KnowledgeBaseArticle | null> {
    return fetchWithCache(`kb:${slug}`, async () => {
        const response = await payloadRest.get<{
            docs: KnowledgeBaseArticle[]
        }>('/knowledge-base', {
            where: {
                slug: { equals: slug },
                status: { equals: 'published' }
            },
            limit: 1
        })

        return response.docs[0] || null
    })
}

export async function fetchAllKnowledgeBase(
    category?: string
): Promise<KnowledgeBaseArticle[]> {
    const cacheKey = category ? `kb:category:${category}` : 'kb:all'

    return fetchWithCache(cacheKey, async () => {
        const where: any = {
            status: { equals: 'published' }
        }

        if (category) {
            where.category = { equals: category }
        }

        const response = await payloadRest.get<{
            docs: KnowledgeBaseArticle[]
        }>('/knowledge-base', {
            where,
            limit: 1000,
            sort: 'title'
        })

        return response.docs
    })
}

export async function fetchFAQs(category?: string): Promise<FAQ[]> {
    const cacheKey = category ? `faq:category:${category}` : 'faq:all'

    return fetchWithCache(cacheKey, async () => {
        const where: any = {}

        if (category) {
            where.category = { equals: category }
        }

        const response = await payloadRest.get<{ docs: FAQ[] }>('/faqs', {
            where,
            limit: 1000,
            sort: 'order'
        })

        return response.docs
    })
}

export async function fetchPricingPlans(): Promise<PricingPlan[]> {
    return fetchWithCache('pricing:all', async () => {
        const response = await payloadRest.get<{ docs: PricingPlan[] }>(
            '/pricing-plans',
            {
                limit: 100,
                sort: 'order'
            }
        )

        return response.docs
    })
}

export async function fetchSolution(slug: string): Promise<Solution | null> {
    return fetchWithCache(`solution:${slug}`, async () => {
        const response = await payloadRest.get<{ docs: Solution[] }>(
            '/solutions',
            {
                where: {
                    slug: { equals: slug },
                    status: { equals: 'published' }
                },
                limit: 1
            }
        )

        return response.docs[0] || null
    })
}

export async function fetchAllSolutions(): Promise<Solution[]> {
    return fetchWithCache('solutions:all', async () => {
        const response = await payloadRest.get<{ docs: Solution[] }>(
            '/solutions',
            {
                where: {
                    status: { equals: 'published' }
                },
                limit: 100
            }
        )

        return response.docs
    })
}

export async function fetchSiteSettings(): Promise<SiteSettings> {
    return fetchWithCache('site-settings', async () => {
        return payloadRest.get<SiteSettings>('/globals/site-settings')
    })
}

// Form submission
export async function submitForm(data: {
    formType: 'contact' | 'demo' | 'waitlist' | 'newsletter' | 'support'
    name?: string
    email: string
    company?: string
    phone?: string
    message?: string
    metadata?: Record<string, any>
}): Promise<void> {
    await payloadRest.post('/form-submissions', {
        ...data,
        submittedAt: new Date().toISOString(),
        status: 'new'
    })
}
